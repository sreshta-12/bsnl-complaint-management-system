/*
 Copyright (C) Federico Zivolo 2018
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */ (function (
  e,
  t
) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = t())
    : "function" === typeof define && define.amd
    ? define(t)
    : (e.Popper = t());
})(this, () => {
  "use strict";

  function e(e) {
    return e && "[object Function]" === {}.toString.call(e);
  }
  function t(e, t) {
    if (e.nodeType !== 1) return [];
    const o = e.ownerDocument.defaultView;
    var n = o.getComputedStyle(e, null);
    return t ? n[t] : n;
  }
  function o(e) {
    return "HTML" === e.nodeName ? e : e.parentNode || e.host;
  }
  function n(e) {
    if (!e) return document.body;
    switch (e.nodeName) {
      case "HTML":
      case "BODY":
        return e.ownerDocument.body;
      case "#document":
        return e.body;
    }
    const i = t(e);
    let r = i.overflow;
    var p = i.overflowX;
    let s = i.overflowY;
    return /(auto|scroll|overlay)/.test(r + s + p) ? e : n(o(e));
  }
  function r(e) {
    return e === 11 ? pe : e === 10 ? se : pe || se;
  }
  function p(e) {
    if (!e) return document.documentElement;
    for (
      var o = r(10) ? document.body : null, n = e.offsetParent || null;
      n === o && e.nextElementSibling;

    )
      n = (e = e.nextElementSibling).offsetParent;
    const i = n && n.nodeName;
    return i && i !== 'BODY' && i !== 'HTML'
      ? ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) !== -1
        && 'static' === t(n, 'position')
        ? p(n)
        : n
      : e
      ? e.ownerDocument.documentElement
      : document.documentElement;
  }
  function s(e) {
    const t = e.nodeName;
    return t !== 'BODY' && (t === 'HTML' || p(e.firstElementChild) === e);
  }
  function d(e) {
    return e.parentNode === null ? e : d(e.parentNode);
  }
  function a(e, t) {
    if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement;
    const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING;
    var n = o ? e : t;
    let i = o ? t : e;
    var r = document.createRange();
    r.setStart(n, 0), r.setEnd(i, 0);
    const l = r.commonAncestorContainer;
    if ((e !== l && t !== l) || n.contains(i)) return s(l) ? l : p(l);
    const f = d(e);
    return f.host ? a(f.host, t) : a(e, d(t).host);
  }
  function l(e) {
    const t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 'top';
      let o = 'top' === t ? 'scrollTop' : 'scrollLeft';
      let n = e.nodeName;
    if (n === 'BODY' || n === 'HTML') {
      const i = e.ownerDocument.documentElement;
      let r = e.ownerDocument.scrollingElement || i;
      return r[o];
    }
    return e[o];
  }
  function f(e, t) {
    const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var n = l(t, 'top');
    let i = l(t, 'left');
    var r = o ? -1 : 1;
    return (
      (e.top += n * r),
      (e.bottom += n * r),
      (e.left += i * r),
      (e.right += i * r),
      e
    );
  }
  function m(e, t) {
    const o = t === 'x' ? 'Left' : 'Top';
      let n = o == 'Left' ? 'Right' : 'Bottom';
    return (
      parseFloat(e[`border${  o  }Width`], 10)
      parseFloat(e["border" + n + "Width"], 10)
    );
  }
  function h(e, t, o, n) {
    return ee(
      t["offset" + e],
      t["scroll" + e],
      o["client" + e],
      o["offset" + e],
      o["scroll" + e],
      r(10)
        ? parseInt(o[`offset${  e}`])
            + parseInt(n[`margin${  'Height' === e ? 'Top' : 'Left'}`])
            + parseInt(n[`margin${  'Height' === e ? 'Bottom' : 'Right'}`])
        : 0
    );
  }
  function c(e) {
    const t = e.body;
    var o = e.documentElement;
    let n = r(10) && getComputedStyle(o);
    return { height: h("Height", t, o, n), width: h("Width", t, o, n) };
  }
  function g(e) {
    return { ...e, right: e.left + e.width, bottom: e.top + e.height };
  }
  function u(e) {
    let o = {};
    try {
      if (r(10)) {
        o = e.getBoundingClientRect();
        const n = l(e, "top");
        var i = l(e, 'left');
        (o.top += n), (o.left += i), (o.bottom += n), (o.right += i);
      } else o = e.getBoundingClientRect();
    } catch (t) {}
    const p = {
      left: o.left,
      top: o.top,
      width: o.right - o.left,
      height: o.bottom - o.top,
    };
    var s = 'HTML' === e.nodeName ? c(e.ownerDocument) : {};
    var d = s.width || e.clientWidth || p.right - p.left;
    var a = s.height || e.clientHeight || p.bottom - p.top;
    let f = e.offsetWidth - d;
    var h = e.offsetHeight - a;
    if (f || h) {
      const u = t(e);
      (f -= m(u, "x")), (h -= m(u, "y")), (p.width -= f), (p.height -= h);
    }
    return g(p);
  }
  function b(e, o) {
    const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var p = r(10);
    let s = 'HTML' === o.nodeName;
    var d = u(e);
    let a = u(o);
    let l = n(e);
    var m = t(o);
    let h = parseFloat(m.borderTopWidth, 10);
    let c = parseFloat(m.borderLeftWidth, 10);
    i && s && ((a.top = ee(a.top, 0)), (a.left = ee(a.left, 0)));
    let b = g({
      top: d.top - a.top - h,
      left: d.left - a.left - c,
      width: d.width,
      height: d.height,
    });
    if (((b.marginTop = 0), (b.marginLeft = 0), !p && s)) {
      const w = parseFloat(m.marginTop, 10);
      var y = parseFloat(m.marginLeft, 10);
      (b.top -= h - w),
        (b.bottom -= h - w),
        (b.left -= c - y),
        (b.right -= c - y),
        (b.marginTop = w),
        (b.marginLeft = y);
    }
    return (
      (p && !i ? o.contains(l) : o === l && l.nodeName !== 'BODY')
        (b = f(b, o)),
      b
    );
  }
  function w(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var o = e.ownerDocument.documentElement;
    var n = b(e, o);
    var i = ee(o.clientWidth, window.innerWidth || 0);
    let r = ee(o.clientHeight, window.innerHeight || 0);
    var p = t ? 0 : l(o);
    var s = t ? 0 : l(o, 'left');
    let d = {
      top: p - n.top + n.marginTop,
      left: s - n.left + n.marginLeft,
      width: i,
      height: r,
    };
    return g(d);
  }
  function y(e) {
    const n = e.nodeName;
    return n === 'BODY' || n === 'HTML'
      ? !1
      : "fixed" === t(e, "position") || y(o(e));
  }
  function E(e) {
    if (!e || !e.parentElement || r()) return document.documentElement;
    for (var o = e.parentElement; o && t(o, 'transform') === 'none';) o = o.parentElement;
    return o || document.documentElement;
  }
  function v(e, t, i, r) {
    const p = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    var s = { top: 0, left: 0 };
    let d = p ? E(e) : a(e, t);
    if ("viewport" === r) s = w(d, p);
    else {
      let l;
      "scrollParent" === r
        ? ((l = n(o(t))),
          "BODY" === l.nodeName && (l = e.ownerDocument.documentElement))
        : "window" === r
        ? (l = e.ownerDocument.documentElement)
        : (l = r);
      const f = b(l, d, p);
      if ("HTML" === l.nodeName && !y(d)) {
        const m = c(e.ownerDocument);
        var h = m.height;
        let g = m.width;
        (s.top += f.top - f.marginTop),
          (s.bottom = h + f.top),
          (s.left += f.left - f.marginLeft),
          (s.right = g + f.left);
      } else s = f;
    }
    i = i || 0;
    const u = "number" === typeof i;
    return (
      (s.left += u ? i : i.left || 0),
      (s.top += u ? i : i.top || 0),
      (s.right -= u ? i : i.right || 0),
      (s.bottom -= u ? i : i.bottom || 0),
      s
    );
  }
  function x(e) {
    const t = e.width;
    var o = e.height;
    return t * o;
  }
  function O(e, t, o, n, i) {
    const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
    if (e.indexOf('auto') === -1) return e;
    const p = v(o, n, r, i);
    var s = {
      top: { width: p.width, height: t.top - p.top },
      right: { width: p.right - t.right, height: p.height },
      bottom: { width: p.width, height: p.bottom - t.bottom },
      left: { width: t.left - p.left, height: p.height },
    };
    let d = Object.keys(s)
      .map((e) => {
        return {key: e, ...s[e], area: x(s[e])};
      })
      .sort((e, t) => {
        return t.area - e.area;
      });
    let a = d.filter((e) => {
      var t = e.width;
          var n = e.height;
      return t >= o.clientWidth && n >= o.clientHeight;
    });
    var l = a.length > 0 ? a[0].key : d[0].key;
    var f = e.split('-')[1];
    return l + (f ? `-${  f}` : '');
  }
  function L(e, t, o) {
    const n =
      arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    var i = n ? E(t) : a(t, o);
    return b(o, i, n);
  }
  function S(e) {
    const t = e.ownerDocument.defaultView;
    var o = t.getComputedStyle(e);
    let n = parseFloat(o.marginTop || 0) + parseFloat(o.marginBottom || 0);
    var i = parseFloat(o.marginLeft || 0) + parseFloat(o.marginRight || 0);
    let r = { width: e.offsetWidth + i, height: e.offsetHeight + n };
    return r;
  }
  function T(e) {
    const t = {
      left: 'right', right: 'left', bottom: 'top', top: 'bottom', 
    };
    return e.replace(/left|right|bottom|top/g, (e) => t[e]);
  }
  function D(e, t, o) {
    o = o.split("-")[0];
    const n = S(e);
    let i = { width: n.width, height: n.height };
    var r = ["right", "left"].indexOf(o) !== -1;
    var p = r ? 'top' : 'left';
    let s = r ? 'left' : 'top';
    let d = r ? 'height' : 'width';
    var a = r ? 'width' : 'height';
    return (
      (i[p] = t[p] + t[d] / 2 - n[d] / 2),
      (i[s] = o === s ? t[s] - n[a] : t[T(s)]),
      i
    );
  }
  function C(e, t) {
    return Array.prototype.find ? e.find(t) : e.filter(t)[0];
  }
  function N(e, t, o) {
    if (Array.prototype.findIndex)
      {return e.findIndex((e) => {
        return e[t] === o;
      });}
    const n = C(e, (e) => e[t] === o);
    return e.indexOf(n);
  }
  function P(t, o, n) {
    const i = void 0 === n ? t : t.slice(0, N(t, "name", n));
    return (
      i.forEach((t) => {
        t.function
          && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
        const n = t.function || t.fn;
        t.enabled &&
          e(n) &&
          ((o.offsets.popper = g(o.offsets.popper)),
          (o.offsets.reference = g(o.offsets.reference)),
          (o = n(o, t)));
      }),
      o
    );
  }
  function k() {
    if (!this.state.isDestroyed) {
      let e = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: !1,
        offsets: {},
      };
      (e.offsets.reference = L(
        this.state,
        this.popper,
        this.reference,
        this.options.positionFixed
      )),
        (e.placement = O(
          this.options.placement,
          e.offsets.reference,
          this.popper,
          this.reference,
          this.options.modifiers.flip.boundariesElement,
          this.options.modifiers.flip.padding
        )),
        (e.originalPlacement = e.placement),
        (e.positionFixed = this.options.positionFixed),
        (e.offsets.popper = D(this.popper, e.offsets.reference, e.placement)),
        (e.offsets.popper.position = this.options.positionFixed
          ? "fixed"
          : "absolute"),
        (e = P(this.modifiers, e)),
        this.state.isCreated
          ? this.options.onUpdate(e)
          : ((this.state.isCreated = !0), this.options.onCreate(e));
    }
  }
  function W(e, t) {
    return e.some((e) => {
      const o = e.name;
      var n = e.enabled;
      return n && o === t;
    });
  }
  function H(e) {
    for (
      let t = [!1, "ms", "Webkit", "Moz", "O"],
        o = e.charAt(0).toUpperCase() + e.slice(1),
        n = 0;
      n < t.length;
      n++
    ) {
      const i = t[n];
      var r = i ? `${  i  }${o}` : e;
      if ("undefined" !== typeof document.body.style[r]) return r;
    }
    return null;
  }
  function B() {
    return (
      (this.state.isDestroyed = !0),
      W(this.modifiers, "applyStyle") &&
        (this.popper.removeAttribute("x-placement"),
        (this.popper.style.position = ""),
        (this.popper.style.top = ""),
        (this.popper.style.left = ""),
        (this.popper.style.right = ""),
        (this.popper.style.bottom = ""),
        (this.popper.style.willChange = ""),
        (this.popper.style[H("transform")] = "")),
      this.disableEventListeners(),
      this.options.removeOnDestroy &&
        this.popper.parentNode.removeChild(this.popper),
      this
    );
  }
  function A(e) {
    const t = e.ownerDocument;
    return t ? t.defaultView : window;
  }
  function M(e, t, o, i) {
    const r = "BODY" === e.nodeName;
    let p = r ? e.ownerDocument.defaultView : e;
    p.addEventListener(t, o, { passive: !0 }),
      r || M(n(p.parentNode), t, o, i),
      i.push(p);
  }
  function F(e, t, o, i) {
    (o.updateBound = i),
      A(e).addEventListener("resize", o.updateBound, { passive: !0 });
    const r = n(e);
    return (
      M(r, "scroll", o.updateBound, o.scrollParents),
      (o.scrollElement = r),
      (o.eventsEnabled = !0),
      o
    );
  }
  function I() {
    this.state.eventsEnabled ||
      (this.state = F(
        this.reference,
        this.options,
        this.state,
        this.scheduleUpdate
      ));
  }
  function R(e, t) {
    return (
      A(e).removeEventListener("resize", t.updateBound),
      t.scrollParents.forEach((e) => {
        e.removeEventListener("scroll", t.updateBound);
      }),
      (t.updateBound = null),
      (t.scrollParents = []),
      (t.scrollElement = null),
      (t.eventsEnabled = !1),
      t
    );
  }
  function U() {
    this.state.eventsEnabled &&
      (cancelAnimationFrame(this.scheduleUpdate),
      (this.state = R(this.reference, this.state)));
  }
  function Y(e) {
    return "" !== e && !isNaN(parseFloat(e)) && isFinite(e);
  }
  function j(e, t) {
    Object.keys(t).forEach((o) => {
      let n = "";
      ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1
        && Y(t[o]) &&
        (n = "px"),
        (e.style[o] = t[o] + n);
    });
  }
  function V(e, t) {
    Object.keys(t).forEach((o) => {
      const n = t[o];
      !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]);
    });
  }
  function q(e, t) {
    const o = e.offsets;
    var n = o.popper;
    let i = o.reference;
    var r = ["left", "right"].indexOf(e.placement) !== -1;
    var p = e.placement.indexOf("-") !== -1;
    let s = i.width % 2 == n.width % 2;
    var d = i.width % 2 == 1 && n.width % 2 == 1;
    var a = function (e) {
      return e;
    };
    let l = t ? (r || p || s ? $ : Z) : a;
    let f = t ? $ : a;
    return {
      left: l(d && !p && t ? n.left - 1 : n.left),
      top: f(n.top),
      bottom: f(n.bottom),
      right: l(n.right),
    };
  }
  function K(e, t, o) {
    const n = C(e, (e) => {
      let o = e.name;
      return o === t;
    });
    var i = !!n
      e.some((e) => e.name === o && e.enabled && e.order < n.order);
    if (!i) {
      const r = "`" + t + "`";
      console.warn(
        "`" +
          o +
          "`" +
          " modifier is required by " +
          r +
          " modifier in order to work, be sure to include it before " +
          r +
          "!"
      );
    }
    return i;
  }
  function z(e) {
    return e === 'end' ? 'start' : e === 'start' ? 'end' : e;
  }
  function G(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var o = ce.indexOf(e);
    let n = ce.slice(o + 1).concat(ce.slice(0, o));
    return t ? n.reverse() : n;
  }
  function _(e, t, o, n) {
    const i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var r = +i[1];
    let p = i[2];
    if (!r) return e;
    if (p.indexOf('%') === 0) {
      let s;
      switch (p) {
        case "%p":
          s = o;
          break;
        case "%":
        case "%r":
        default:
          s = n;
      }
      const d = g(s);
      return (d[t] / 100) * r;
    }
    if (p === 'vh' || p === 'vw') {
      let a;
      return (
        (a =
          'vh' === p
          ? ee(document.documentElement.clientHeight, window.innerHeight || 0)
          : ee(document.documentElement.clientWidth, window.innerWidth || 0)),
        (a / 100) * r
      );
    }
    return r;
  }
  function X(e, t, o, n) {
    const i = [0, 0];
    let r = ["right", "left"].indexOf(n) !== -1;
    var p = e.split(/(\+|\-)/).map((e) => {
      return e.trim();
    });
    var s = p.indexOf(
      C(p, (e) => e.search(/,|\s/) !== -1),
    );
    p[s] &&
      -1 === p[s].indexOf(",") &&
      console.warn(
        "Offsets separated by white space(s) are deprecated, use a comma (,) instead."
      );
    const d = /\s*,\s*|\s+/;
    var a = -1 === s
      ? [p]
        : [
        p.slice(0, s).concat([p[s].split(d)[0]]),
        [p[s].split(d)[1]].concat(p.slice(s + 1)),
      ];
    return (
      (a = a.map((e, n) => {
        let i = (n === 1 ? !r : r) ? "height" : "width",
          p = !1;
        return e
          .reduce((e, t) => '' === e[e.length - 1] && ["+", "-"].indexOf(t) !== -1
              ? ((e[e.length - 1] = t), (p = !0), e)
              : p
                ? ((e[e.length - 1] += t), (p = !1), e)
                : e.concat(t), [])
          .map((e) => _(e, i, t, o));
      })),
      a.forEach((e, t) => {
        e.forEach((o, n) => {
          Y(o) && (i[t] += o * ("-" === e[n - 1] ? -1 : 1));
        });
      }),
      i
    );
  }
  function J(e, t) {
    let o;
    let n = t.offset;
    var i = e.placement;
    var r = e.offsets;
    let p = r.popper;
    var s = r.reference;
    var d = i.split('-')[0];
    return (
      (o = Y(+n) ? [+n, 0] : X(n, p, s, d)),
      "left" === d
        ? ((p.top += o[0]), (p.left -= o[1]))
        : "right" === d
        ? ((p.top += o[0]), (p.left += o[1]))
        : "top" === d
        ? ((p.left += o[0]), (p.top -= o[1]))
        : "bottom" === d && ((p.left += o[0]), (p.top += o[1])),
      (e.popper = p),
      e
    );
  }
  for (
    var Q = Math.min,
      Z = Math.floor,
      $ = Math.round,
      ee = Math.max,
      te = typeof window !== 'undefined' && typeof document !== 'undefined',
      oe = ["Edge", "Trident", "Firefox"],
      ne = 0,
      ie = 0;
    ie < oe.length;
    ie += 1
  )
    {if (te && navigator.userAgent.indexOf(oe[ie]) >= 0) {
      ne = 1;
      break;
    }}
  let i = te && window.Promise;
  let re = i
    ? function (e) {
      var t = !1;
        return function () {
        t
              || ((t = !0),
            window.Promise.resolve().then(() => {
              (t = !1), e();
            }));
        };
    }
    : function (e) {
      var t = !1;
        return function () {
          t
              || ((t = !0),
            setTimeout(() => {
              (t = !1), e();
            }, ne));
      };
      };
  var pe = te && !!(window.MSInputMethodContext && document.documentMode);
  var se = te && /MSIE 10/.test(navigator.userAgent);
  var de = function (e, t) {
    if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
  };
  let ae = (function () {
    function e(e, t) {
      for (var o, n = 0; n < t.length; n++) (o = t[n]),
          (o.enumerable = o.enumerable || !1),
        (o.configurable = !0),
          'value' in o && (o.writable = !0),
          Object.defineProperty(e, o.key, o);
    }
    return function (t, o, n) {
      return o && e(t.prototype, o), n && e(t, n), t;
    };
  }());
  var le = function (e, t, o) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
          value: o,
            enumerable: !0,
          configurable: !0,
          writable: !0,
          })
        : (e[t] = o),
      e
    );
  };
  var fe =      Object.assign
      || function (e) {
      for (var t, o = 1; o < arguments.length; o++) for (let n in ((t = arguments[o]), t)) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      return e;
    };
  let me = te && /Firefox/i.test(navigator.userAgent);
  var he = [
    "auto-start",
    'auto',
    "auto-end",
    "top-start",
    "top",
    'top-end',
    "right-start",
    "right",
    'right-end',
    "bottom-end",
    "bottom",
    "bottom-start",
    'left-end',
    "left",
    "left-start",
  ];
  var ce = he.slice(3);
  var ge = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise',
  };
  let ue = (function () {
    function t(o, n) {
      let i = this;
      var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
      de(this, t),
      (this.scheduleUpdate = function () {
        return requestAnimationFrame(i.update);
      }),
      (this.update = re(this.update.bind(this))),
      (this.options = { ...t.Defaults, ...r }),
      (this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }),
      (this.reference = o && o.jquery ? o[0] : o),
      (this.popper = n && n.jquery ? n[0] : n),
      (this.options.modifiers = {}),
      Object.keys({ ...t.Defaults.modifiers, ...r.modifiers }).forEach(
        function (e) {
          i.options.modifiers[e] = {

            ...t.Defaults.modifiers[e] || {},
            ...(r.modifiers ? r.modifiers[e] : {}),
            };
        }
      ),
      (this.modifiers = Object.keys(this.options.modifiers)
        .map((e) => ({name: e, ...i.options.modifiers[e]}))
        .sort((e, t) => e.order - t.order)),
      this.modifiers.forEach((t) => {
        t.enabled &&
            e(t.onLoad) &&
            t.onLoad(i.reference, i.popper, i.options, t, i.state);
      }),
      this.update();
      let p = this.options.eventsEnabled;
      p && this.enableEventListeners(), (this.state.eventsEnabled = p);
    }
    return (
      ae(t, [
        {
          key: 'update',
          value() {
            return k.call(this);
          },
        },
        {
          key: 'destroy',
          value() {
            return B.call(this);
          },
        },
        {
          key: 'enableEventListeners',
          value() {
            return I.call(this);
          },
        },
        {
          key: 'disableEventListeners',
          value() {
            return U.call(this);
          },
        },
      ]),
      t
    );
  }());
  return (
    (ue.Utils = ("undefined" === typeof window ? global : window).PopperUtils),
    (ue.placements = he),
    (ue.Defaults = {
      placement: "bottom",
      positionFixed: !1,
      eventsEnabled: !0,
      removeOnDestroy: !1,
      onCreate() {},
      onUpdate() {},
      modifiers: {
        shift: {
          order: 100,
          enabled: !0,
          fn(e) {
            let t = e.placement;
              var o = t.split("-")[0];
              var n = t.split('-')[1];
            if (n) {
              let i = e.offsets;
                var r = i.reference;
                var p = i.popper;
                var s = -1 !== ["bottom", "top"].indexOf(o);
                var d = s ? "left" : "top";
                var a = s ? "width" : "height";
                var l = {
                  start: le({}, d, r[d]),
                  end: le({}, d, r[d] + r[a] - p[a]),
                };
              e.offsets.popper = { ...p, ...l[n]};
            }
            return e;
          },
        },
        offset: {
          order: 200, enabled: !0, fn: J, offset: 0, 
        },
        preventOverflow: {
          order: 300,
          enabled: !0,
          fn(e, t) {
            let o = t.boundariesElement || p(e.instance.popper);
            e.instance.reference === o && (o = p(o));
            let n = H('transform');
              var i = e.instance.popper.style;
              var r = i.top;
              var s = i.left;
              var d = i[n];
            (i.top = ''), (i.left = ''), (i[n] = '');
            let a = v(
              e.instance.popper,
              e.instance.reference,
              t.padding,
              o,
              e.positionFixed,
            );
            (i.top = r), (i.left = s), (i[n] = d), (t.boundaries = a);
            let l = t.priority;
              var f = e.offsets.popper;
              var m = {
                primary (e) {
                  var o = f[e];
                  return (
                    f[e] < a[e] &&
                      !t.escapeWithReference &&
                      (o = ee(f[e], a[e])),
                    le({}, e, o)
                  );
                },
                secondary (e) {
                  var o = "right" === e ? "left" : "top",
                    n = f[o];
                  return (
                    f[e] > a[e] &&
                      !t.escapeWithReference &&
                      (n = Q(
                        f[o],
                        a[e] - ("right" === e ? f.width : f.height)
                      )),
                    le({}, o, n)
                  );
                },
              };
            return (
              l.forEach((e) => {
                let t =                  -1 === ['left', 'top'].indexOf(e) ? 'secondary' : 'primary';
                f = { ...f, ...m[t](e)};
              }),
              (e.offsets.popper = f),
              e
            );
          },
          priority: ["left", "right", "top", "bottom"],
          padding: 5,
          boundariesElement: "scrollParent",
        },
        keepTogether: {
          order: 400,
          enabled: !0,
          fn(e) {
            let t = e.offsets;
              var o = t.popper;
              var n = t.reference;
              var i = e.placement.split("-")[0];
              var r = Z;
              var p = -1 !== ["top", "bottom"].indexOf(i);
              var s = p ? "right" : "bottom";
              var d = p ? "left" : "top";
              var a = p ? 'width' : 'height';
            return (
              o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]),
              o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])),
              e
            );
          },
        },
        arrow: {
          order: 500,
          enabled: !0,
          fn(e, o) {
            let n;
            if (!K(e.instance.modifiers, 'arrow', 'keepTogether')) return e;
            let i = o.element;
            if ('string' === typeof i) {
              if (((i = e.instance.popper.querySelector(i)), !i)) return e;
            } else if (!e.instance.popper.contains(i)) return (
                console.warn(
                  'WARNING: `arrow.element` must be child of its popper element!'
                ),
                e
              );
            let r = e.placement.split('-')[0];
              var p = e.offsets;
              var s = p.popper;
              var d = p.reference;
              var a = -1 !== ["left", "right"].indexOf(r);
              var l = a ? "height" : "width";
              var f = a ? "Top" : "Left";
              var m = f.toLowerCase();
              var h = a ? "left" : "top";
              var c = a ? "bottom" : "right";
              var u = S(i)[l];
            d[c] - u < s[m] && (e.offsets.popper[m] -= s[m] - (d[c] - u)),
            d[m] + u > s[c] && (e.offsets.popper[m] += d[m] + u - s[c]),
            (e.offsets.popper = g(e.offsets.popper));
            let b = d[m] + d[l] / 2 - u / 2;
              var w = t(e.instance.popper);
              var y = parseFloat(w["margin" + f], 10);
              var E = parseFloat(w["border" + f + "Width"], 10);
              var v = b - e.offsets.popper[m] - y - E;
            return (
              (v = ee(Q(s[l] - u, v), 0)),
              (e.arrowElement = i),
              (e.offsets.arrow = ((n = {}), le(n, m, $(v)), le(n, h, ''), n)),
              e
            );
          },
          element: "[x-arrow]",
        },
        flip: {
          order: 600,
          enabled: !0,
          fn(e, t) {
            if (W(e.instance.modifiers, 'inner')) return e;
            if (e.flipped && e.placement === e.originalPlacement) return e;
            let o = v(
                e.instance.popper,
                e.instance.reference,
                t.padding,
                t.boundariesElement,
                e.positionFixed,
              );
              var n = e.placement.split("-")[0];
              var i = T(n);
              var r = e.placement.split("-")[1] || "";
              var p = [];
            switch (t.behavior) {
              case ge.FLIP:
                p = [n, i];
                break;
              case ge.CLOCKWISE:
                p = G(n);
                break;
              case ge.COUNTERCLOCKWISE:
                p = G(n, !0);
                break;
              default:
                p = t.behavior;
            }
            return (
              p.forEach((s, d) => {
                if (n !== s || p.length === d + 1) return e;
                (n = e.placement.split('-')[0]), (i = T(n));
                let a = e.offsets.popper;
                  var l = e.offsets.reference;
                  var f = Z;
                  var m =
                    ("left" === n && f(a.right) > f(l.left)) ||
                    ("right" === n && f(a.left) < f(l.right)) ||
                    ("top" === n && f(a.bottom) > f(l.top)) ||
                    ("bottom" === n && f(a.top) < f(l.bottom));
                  var h = f(a.left) < f(o.left);
                  var c = f(a.right) > f(o.right);
                  var g = f(a.top) < f(o.top);
                  var u = f(a.bottom) > f(o.bottom);
                  var b =
                    ("left" === n && h) ||
                    ("right" === n && c) ||
                    ("top" === n && g) ||
                    ("bottom" === n && u);
                  var w = -1 !== ["top", "bottom"].indexOf(n);
                  var y =                    !!t.flipVariations
                    && ((w && 'start' === r && h)
                      || (w && 'end' === r && c)
                      || (!w && 'start' === r && g)
                      || (!w && 'end' === r && u));
                (m || b || y)
                  && ((e.flipped = !0),
                  (m || b) && (n = p[d + 1]),
                  y && (r = z(r)),
                  (e.placement = n + (r ? '-' + r : '')),
                  (e.offsets.popper = {
                    
                    ...e.offsets.popper,
                    ...D(e.instance.popper, e.offsets.reference, e.placement)
                  }),
                  (e = P(e.instance.modifiers, e, 'flip')));
              }),
              e
            );
          },
          behavior: "flip",
          padding: 5,
          boundariesElement: "viewport",
        },
        inner: {
          order: 700,
          enabled: !1,
          fn(e) {
            let t = e.placement;
              var o = t.split("-")[0];
              var n = e.offsets;
              var i = n.popper;
              var r = n.reference;
              var p = -1 !== ["left", "right"].indexOf(o);
              var s = ["top", "left"].indexOf(o) === -1;
            return (
              (i[p ? 'left' : 'top'] =                r[o] - (s ? i[p ? 'width' : 'height'] : 0)),
              (e.placement = T(t)),
              (e.offsets.popper = g(i)),
              e
            );
          },
        },
        hide: {
          order: 800,
          enabled: !0,
          fn(e) {
            if (!K(e.instance.modifiers, 'hide', 'preventOverflow')) return e;
            let t = e.offsets.reference;
              var o = C(e.instance.modifiers, (e) => {
                return 'preventOverflow' === e.name;
              }).boundaries;
            if (
              t.bottom < o.top
              || t.left > o.right
              || t.top > o.bottom
              || t.right < o.left
            ) {
              if (!0 === e.hide) return e;
              (e.hide = !0), (e.attributes['x-out-of-boundaries'] = '');
            } else {
              if (!1 === e.hide) return e;
              (e.hide = !1), (e.attributes['x-out-of-boundaries'] = !1);
            }
            return e;
          },
        },
        computeStyle: {
          order: 850,
          enabled: !0,
          fn(e, t) {
            let o = t.x;
              var n = t.y;
              var i = e.offsets.popper;
              var r = C(e.instance.modifiers, (e) => {
                return 'applyStyle' === e.name;
              }).gpuAcceleration;
            void 0 !== r
              && console.warn(
                'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'
              );
            let s;
              var d;
              var a = void 0 === r ? t.gpuAcceleration : r;
              var l = p(e.instance.popper);
              var f = u(l);
              var m = { position: i.position };
              var h = q(e, 2 > window.devicePixelRatio || !me);
              var c = "bottom" === o ? "top" : "bottom";
              var g = "right" === n ? "left" : "right";
              var b = H('transform');
            if (
              ((d =                "bottom" == c
                  ? 'HTML' === l.nodeName
                    ? -l.clientHeight + h.bottom
                    : -f.height + h.bottom
                  : h.top),
              (s =                "right" == g
                  ? 'HTML' === l.nodeName
                    ? -l.clientWidth + h.right
                    : -f.width + h.right
                  : h.left),
              a && b)
            ) (m[b] = 'translate3d(' + s + 'px, ' + d + 'px, 0)'),
              (m[c] = 0),
              (m[g] = 0),
              (m.willChange = 'transform');
            else {
              let w = 'bottom' == c ? -1 : 1;
                var y = 'right' == g ? -1 : 1;
              (m[c] = d * w), (m[g] = s * y), (m.willChange = `${c  }, ${  g}`);
            }
            let E = { 'x-placement': e.placement };
            return (
              (e.attributes = { ...E, ...e.attributes}),
              (e.styles = { ...m, ...e.styles}),
              (e.arrowStyles = { ...e.offsets.arrow, ...e.arrowStyles}),
              e
            );
          },
          gpuAcceleration: !0,
          x: "bottom",
          y: "right",
        },
        applyStyle: {
          order: 900,
          enabled: !0,
          fn(e) {
            return (
              j(e.instance.popper, e.styles),
              V(e.instance.popper, e.attributes),
              e.arrowElement
                && Object.keys(e.arrowStyles).length
                && j(e.arrowElement, e.arrowStyles),
              e
            );
          },
          onLoad(e, t, o, n, i) {
            let r = L(i, t, e, o.positionFixed);
              var p = O(
                o.placement,
                r,
                t,
                e,
                o.modifiers.flip.boundariesElement,
                o.modifiers.flip.padding,
              );
            return (
              t.setAttribute('x-placement', p),
              j(t, { position: o.positionFixed ? 'fixed' : 'absolute' }),
              o
            );
          },
          gpuAcceleration: void 0,
        },
      },
    }),
    ue
  );
});
// # sourceMappingURL=popper.min.js.map
